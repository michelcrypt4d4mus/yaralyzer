{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>This is an embedded verson of the <code>yaralyzer</code> GitHub repository's README.md. A few links may not work here that do work over there.</p> <p> </p>"},{"location":"#the-yaralyzer","title":"THE YARALYZER","text":"<p>Visually inspect all of the regex matches (and their sexier, more cloak and dagger cousins, the YARA matches) found in binary data and/or text. See what happens when you force various character encodings upon those matched bytes. With colors.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>pipx install yaralyzer\n\n# Scan against YARA definitions in a file:\nyaralyze --yara-rules /secret/vault/sigmunds_malware_rules.yara lacan_buys_the_dip.pdf\n\n# Scan against an arbitrary regular expression:\nyaralyze --regex-pattern 'good and evil.*of\\s+\\w+byte' --regex-modifier wide the_crypto_archipelago.exe\n\n# Scan against an arbitrary YARA hex pattern\nyaralyze --hex-pattern 'd0 93 d0 a3 d0 [-] 9b d0 90 d0 93' one_day_in_the_life_of_ivan_cryptosovich.bin\n</code></pre>"},{"location":"#what-it-do","title":"What It Do","text":"<ol> <li>See the actual bytes your YARA rules are matching. No more digging around copy/pasting the start positions reported by YARA into your favorite hex editor. Displays both the bytes matched by YARA as well as a configurable number of bytes before and after each match in hexadecimal and \"raw\" python string representation.</li> <li>Do the same for byte patterns and regular expressions without writing a YARA file. If you're too lazy to write a YARA file but are trying to determine, say, whether there's a regular expression hidden somewhere in the file you could scan for the pattern <code>'/.+/'</code> and immediately get a window into all the bytes in the file that live between front slashes. Same story for quotes, BOMs, etc. Any regex YARA can handle is supported so the sky is the limit.</li> <li>Detect the possible encodings of each set of matched bytes. <code>chardet</code> is a sophisticated library for guessing character encodings and it is leveraged here.</li> <li>Display the result of forcing various character encodings upon the matched areas. Several default character encodings will be forcibly attempted in the region around the match. <code>chardet</code> will also be leveraged to see if the bytes fit the pattern of any known encoding. If <code>chardet</code> is confident enough (configurable) an attempt at decoding the bytes using that encoding will be displayed.</li> <li>Export the matched regions/decodings to SVG, HTML, and colored text files. Show off your ASCII art.</li> </ol>"},{"location":"#why-it-do","title":"Why It Do","text":"<p>The Yaralyzer's functionality was extracted from The Pdfalyzer when it became apparent that visualizing and decoding pattern matches in binaries had more utility than just in a PDF analysis tool.</p> <p>YARA, for those who are unaware[^1], is branded as a malware analysis/alerting tool but it's actually both a lot more and a lot less than that. One way to think about it is that YARA is a regular expression matching engine on steroids. It can locate regex matches in binaries like any regex engine but it can also do far wilder things like combine regexes in logical groups, compare regexes against all 256 XORed versions of a binary, check for <code>base64</code> and other encodings of the pattern, and more.  Maybe most importantly of all YARA provides a standard text based format for people to share their 'roided regexes with the world. All these features are particularly useful when analyzing or reverse engineering malware, whose authors tend to invest a great deal of time into making stuff hard to find.</p> <p>But... that's also all YARA does. Everything else is up to the user. YARA's just a match engine and if you don't know what to match (or even what character encoding you might be able to match in) it only gets you so far. I found myself a bit frustrated trying to use YARA to look at all the matches of a few critical patterns:</p> <ol> <li>Bytes between escaped quotes (<code>\\\".+\\\"</code> and <code>\\'.+\\'</code>)</li> <li>Bytes between front slashes (<code>/.+/</code>). Front slashes demarcate a regular expression in many implementations and I was trying to see if any of the bytes matching this pattern were actually regexes.</li> </ol> <p>YARA just tells you the byte position and the matched string but it can't tell you whether those bytes are UTF-8, UTF-16, Latin-1, etc. etc. (or none of the above). I also found myself wanting to understand what was going in the region of the matched bytes and not just in the matched bytes. In other words I wanted to scope the bytes immediately before and after whatever got matched.</p> <p>Enter The Yaralyzer, which lets you quickly scan the regions around matches while also showing you what those regions would look like if they were forced into various character encodings.</p> <p>The Yaralyzer isn't a malware reversing tool. It can't the things a tool like CyberChef does and it doesn't try to. It's more intended to give you a quick visual overview of suspect regions in the binary so you can hone in on the areas you might want to inspect with a more serious tool.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install it with <code>pipx</code> or <code>pip3</code>. <code>pipx</code> is a marginally better solution as it guarantees any packages installed with it will be isolated from the rest of your local python environment. Of course if you don't really have a local python environment this is a moot point and you can feel free to install with <code>pip</code>/<code>pip3</code>.</p> <pre><code>pipx install yaralyzer\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Run <code>yaralyze -h</code> to see the command line options (screenshot below).</p> <p></p> <p>For info on exporting SVG images, HTML, etc., see Example Output.</p>"},{"location":"#configuration","title":"Configuration","text":"<p>If you place a file called <code>.yaralyzer</code> in your home directory or the current working directory then environment variables specified in that <code>.yaralyzer</code> file will be added to the environment each time yaralyzer is invoked. This provides a mechanism for permanently configuring various command line options so you can avoid typing them over and over. See the comments in the example file <code>.yaralyzer.example</code> for more info.</p> <p>Only one <code>.yaralyzer</code> file will be loaded and the working directory's <code>.yaralyzer</code> takes precedence over the home directory's <code>.yaralyzer</code>.</p>"},{"location":"#as-a-library","title":"As A Library","text":"<p><code>Yaralyzer</code> is the main class. Auto generated documentation for <code>Yaralyzer</code>'s various classes and methods can be found here. It has a variety of alternate constructors supporting:</p> <ol> <li>Precompiled YARA rules</li> <li>Creating a YARA rule from a string</li> <li>Loading YARA rules from files</li> <li>Loading YARA rules from all <code>.yara</code> file in a directory</li> <li>Scanning <code>bytes</code></li> <li>Scanning a file</li> </ol> <p>Should you want to iterate over the <code>BytesMatch</code> (like a <code>re.Match</code> object for a YARA match) and <code>BytesDecoder</code> (tracks decoding attempt stats) objects used by The Yaralyzer, you can do so like this:</p> <pre><code>from yaralyzer.yaralyzer import Yaralyzer\n\nyaralyzer = Yaralyzer.for_rules_files(['/secret/rule.yara'], 'lacan_buys_the_dip.pdf')\n\nfor bytes_match, bytes_decoder in yaralyzer.match_iterator():\n    do_stuff()\n</code></pre>"},{"location":"#troubleshooting","title":"Troubleshooting","text":"<p>If you get a <code>yara.Error</code> with a numerical error code you can check what that code might mean here.</p>"},{"location":"#example-output","title":"Example Output","text":"<p>The Yaralyzer can export visualizations to HTML, ANSI colored text, and both PNG and SVG vector images using the file export functionality that comes with Rich as well as a (somewhat limited) plain text JSON format.</p> <p>If you want to export <code>.png</code> images like the ones below directly from Yaralyzer you'll need to do one of these things:</p> <ol> <li>Install Inkscape (homebrew users can install it with <code>brew install --cask inkscape</code>)</li> <li>Ask for the <code>img</code> extra when installing Yaralyzer which will install <code>cairosvg</code>: <code>pipx install yaralyzer[img]</code>. You'll also have to install the CairoSVG executable manually in different ways depending on your operating system, see the CairoSVG docs for the specifics.</li> </ol> <p>In our experience Inkscape and CairoSVG both work though we've seen some glitchiness in the rendered output using CairoSVG on SVGs rendered by Yaralyzer so Inkscape is the recommended option.</p>"},{"location":"#raw-yara-match-result","title":"Raw YARA match result:","text":""},{"location":"#display-hex-raw-python-string-and-various-attempted-decodings-of-both-the-match-and-the-bytes-before-and-after-the-match-configurable","title":"Display hex, raw python string, and various attempted decodings of both the match and the bytes before and after the match (configurable):","text":""},{"location":"#bonus-see-what-chardetdetect-thinks-about-the-likelihood-your-bytes-are-in-a-given-encodinglanguage","title":"Bonus: see what <code>chardet.detect()</code> thinks about the likelihood your bytes are in a given encoding/language:","text":""},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are more than welcome; see CONTRIBUTING.md for details on environment setup, running the test suite, etc. There's also a TODO list over there of work that needs to be done.</p> <p>[^1]: As I was until recently.</p>"},{"location":"api/","title":"Index","text":""},{"location":"api/#api-overview","title":"API Overview","text":""},{"location":"api/#modules","title":"Modules","text":"<ul> <li><code>bytes_match</code>: <code>BytesMatch</code> class for tracking regex and YARA matches against binary data.</li> <li><code>config</code>: Configuration management for Yaralyzer.</li> <li><code>yaralyzer</code>: Main Yaralyzer class and alternate constructors.</li> <li><code>bytes_decoder</code>: <code>BytesDecoder</code> class for attempting to decode bytes with various encodings.</li> <li><code>decoding_attempt</code>: Class to manage attempting to decode a chunk of bytes into strings with a given encoding.</li> <li><code>character_encodings</code>: Constants related to character encodings.</li> <li><code>encoding_assessment</code>: Helps with <code>chardet</code> library.</li> <li><code>encoding_detector</code>: <code>EncodingDetector</code> class for managing chardet encoding detection.</li> <li><code>console</code>: Holds the rich.Console instance that controls the stdout printing and file export.</li> <li><code>decoding_attempts_table</code>: Methods to build the <code>rich.table</code> used to display decoding attempts of a given bytes array.</li> <li><code>decoding_table_row</code></li> <li><code>file_export</code>: Functions to export Yaralyzer results to various file formats.</li> <li><code>file_hashes_table</code>: Methods for computing and displaying various file hashes.</li> <li><code>regex_match_metrics</code>: <code>RegexMatchMetrics</code> class.</li> <li><code>theme</code>: Color theme stuff. Rich color names</li> <li><code>argument_parser</code>: Argument parsing for yaralyze command line tool (also used by the pdfalyzer).</li> <li><code>classproperty</code></li> <li><code>cli_option_validators</code>: Validators for command line arguments.</li> <li><code>constants</code></li> <li><code>exceptions</code></li> <li><code>logging</code>: Logs are not normally ephemeral/not written to files but can be configured to do so by setting</li> <li><code>timeout</code></li> <li><code>error</code>: Handling of internal YARA errors.</li> <li><code>yara_match</code>: Rich text decorator for YARA match dicts.</li> <li><code>yara_rule_builder</code>: Builds bare bones YARA rules to match strings and regex patterns.</li> </ul>"},{"location":"api/#classes","title":"Classes","text":"<ul> <li><code>bytes_match.BytesMatch</code>: Simple class to keep track of regex matches against binary data.</li> <li><code>config.YaralyzerConfig</code>: Handles parsing of command line args and environment variables for Yaralyzer.</li> <li><code>yaralyzer.Yaralyzer</code>: Central class that handles setting up / compiling YARA rules and reading binary data from files as needed.</li> <li><code>bytes_decoder.BytesDecoder</code>: Handles decoding a chunk of bytes into strings using various possible encodings, ranking and displaying results.</li> <li><code>decoding_attempt.DecodingAttempt</code>: Manages the process of attempting to decode a chunk of bytes into a string using a specified encoding.</li> <li><code>encoding_assessment.EncodingAssessment</code>: Class to smooth some of the rough edges around the <code>dict</code>s returned by <code>chardet.detect_all()</code>.</li> <li><code>encoding_detector.EncodingDetector</code>: Manager class to ease dealing with the encoding detection library <code>chardet</code>.</li> <li><code>decoding_table_row.DecodingTableRow</code>: Simple <code>dataclass</code> to hold a single row of a table of decoding attempts.</li> <li><code>file_hashes_table.BytesInfo</code>: Compute the size, MD5, SHA1, and SHA256 hashes for some bytes.</li> <li><code>regex_match_metrics.RegexMatchMetrics</code>: Class to measure what we enounter as we iterate over all matches of a relatively simple byte level regex.</li> <li><code>classproperty.classproperty</code>: Decorator that mimics chaining @classmethod and @property for a getter. From:</li> <li><code>cli_option_validators.DirValidator</code>: DirValidator(allow_create: bool = False)</li> <li><code>cli_option_validators.OptionValidator</code>: Base class for CLI options validators that needs to be in its own file because of circular</li> <li><code>cli_option_validators.PathValidator</code></li> <li><code>cli_option_validators.PatternsLabelValidator</code></li> <li><code>cli_option_validators.YaraRegexValidator</code></li> <li><code>logging.BufferingFormatter</code>: A formatter suitable for formatting a number of records.</li> <li><code>logging.FileHandler</code>: A handler class which writes formatted logging records to disk files.</li> <li><code>logging.Filter</code>: Filter instances are used to perform arbitrary filtering of LogRecords.</li> <li><code>logging.Filterer</code>: A base class for loggers and handlers which allows them to share</li> <li><code>logging.Formatter</code>: Formatter instances are used to convert a LogRecord to text.</li> <li><code>logging.Handler</code>: Handler instances dispatch logging events to specific destinations.</li> <li><code>logging.LogRecord</code>: A LogRecord instance represents an event being logged.</li> <li><code>logging.Logger</code>: Instances of the Logger class represent a single logging channel. A</li> <li><code>logging.LoggerAdapter</code>: An adapter for loggers which makes it easier to specify contextual</li> <li><code>logging.Manager</code>: There is [under normal circumstances] just one Manager instance, which</li> <li><code>logging.NullHandler</code>: This handler does nothing. It's intended to be used to avoid the</li> <li><code>logging.PercentStyle</code></li> <li><code>logging.PlaceHolder</code>: PlaceHolder instances are used in the Manager logger hierarchy to take</li> <li><code>logging.RootLogger</code>: A root logger is not that different to any other logger, except that</li> <li><code>logging.StrFormatStyle</code></li> <li><code>logging.StreamHandler</code>: A handler class which writes logging records, appropriately formatted,</li> <li><code>logging.StringTemplateStyle</code></li> <li><code>yara_match.YaraMatch</code>: Rich text decorator for YARA match dicts.</li> </ul>"},{"location":"api/#functions","title":"Functions","text":"<ul> <li><code>yaralyzer.yaralyze</code>: Entry point for Yaralyzer when invoked as a script. Args are parsed from the command line</li> <li><code>character_encodings.encoding_offsets</code>: Get possible offsets for a given encoding. If the encoding is not in <code>WIDE_UTF_ENCODINGS</code>, return <code>[0]</code>.</li> <li><code>character_encodings.encoding_width</code>: Get the width of a character in bytes for a given encoding, which is the number of possible offsets.</li> <li><code>character_encodings.is_wide_utf</code>: Check if the encoding is a wide UTF encoding (UTF-16 or UTF-32).</li> <li><code>character_encodings.scrub_c1_control_chars</code>: Fill in a <code>dict</code> with integer keys/values corresponding to where a given char encoding has no chars</li> <li><code>console.console_print_with_fallback</code>: <code>rich.console.print()</code> with fallback to regular <code>print()</code> if there's a Rich Markup issue.</li> <li><code>console.console_width</code>: Current width set in <code>console</code> object.</li> <li><code>decoding_attempts_table.new_decoding_attempts_table</code>: Build a new rich <code>Table</code> with two rows, the raw and hex views of the <code>bytes_match</code> data.</li> <li><code>file_export.export_json</code>: Export YARA scan results to JSON.</li> <li><code>file_export.invoke_rich_export</code>: Announce the export, perform the export, and announce completion.</li> <li><code>file_export.render_png</code>: Turn the svg output into a png with Inkscape or cairosvg. Returns png path if successful.</li> <li><code>file_hashes_table.bytes_hashes_table</code>: Build a Rich <code>Table</code> displaying the size, MD5, SHA1, and SHA256 hashes of a byte sequence.</li> <li><code>theme.argparse_style</code>: RichHelpFormatterPlus strings:</li> <li><code>theme.color_theme_grid</code>: Lay out the colors in 'styles' in a grid with a header panel.</li> <li><code>theme.theme_colors_with_prefix</code>: Return a list of (name, style) <code>Text</code> objects for all styles in the theme that start with <code>prefix</code>.</li> <li><code>argument_parser.epilog</code>: Returns a string with some rich text tags for color to be used as the --help footer.</li> <li><code>argument_parser.show_configurable_env_vars</code>: Show the environment variables that can be used to set command line options, either</li> <li><code>exceptions.print_fatal_error</code>: Print a fatal error message</li> <li><code>exceptions.print_fatal_error_and_exit</code>: Print an error message and exit with code 'exit_code'.</li> <li><code>logging.addLevelName</code>: Associate 'levelName' with 'level'.</li> <li><code>logging.basicConfig</code>: Do basic configuration for the logging system.</li> <li><code>logging.captureWarnings</code>: If capture is true, redirect all warnings to the logging package.</li> <li><code>logging.critical</code>: Log a message with severity 'CRITICAL' on the root logger. If the logger</li> <li><code>timeout.timeout</code>: From:</li> <li><code>error.yara_error_msg</code>: Turn a mysterious YARA error code number into a human readable string.</li> <li><code>yara_rule_builder.build_yara_rule</code>: Build a compiled <code>yara.Rule</code> object.</li> <li><code>yara_rule_builder.safe_label</code>: YARA rule and pattern names can only contain alphanumeric chars.</li> <li><code>yara_rule_builder.yara_rule_string</code>: Build a YARA rule string for a given <code>pattern</code>.</li> </ul> <p>This file was automatically generated via lazydocs.</p>"},{"location":"api/argument_parser/","title":"Argument parser","text":""},{"location":"api/argument_parser/#module-argument_parser","title":"module <code>argument_parser</code>","text":"<p>Argument parsing for yaralyze command line tool (also used by the pdfalyzer). </p>"},{"location":"api/argument_parser/#global-variables","title":"Global Variables","text":"<ul> <li>CONFIDENCE_SCORE_RANGE</li> <li>CLI_OPTION_TYPE_STYLES</li> <li>YARALYZE</li> <li>YARALYZER</li> <li>YARALYZER_UPPER</li> <li>INVOKED_BY_PYTEST</li> <li>KILOBYTE</li> <li>MEGABYTE</li> <li>MAX_FILENAME_LENGTH</li> <li>ECHO_COMMAND_OPTION</li> <li>ENV_VARS_OPTION</li> <li>NO_TIMESTAMPS_OPTION</li> <li>SUPPRESS_OUTPUT_OPTION</li> <li>EARLY_EXIT_ARGS</li> <li>DEFAULT_PYTEST_CLI_ARGS</li> <li>GITHUB_BASE_URL</li> <li>PDFALYZER_REPO_URL</li> <li>YARALYZER_REPO_URL</li> <li>YARALYZER_API_DOCS_URL</li> <li>INKSCAPE</li> <li>INKSCAPE_URL</li> <li>LOG_LEVELS</li> <li>PNG_EXPORT_WARNING</li> <li>YARA_REGEX_MODIFIERS</li> <li>DESCRIPTION</li> </ul>"},{"location":"api/argument_parser/#function-epilog","title":"function <code>epilog</code>","text":"<pre><code>epilog(config: type[YaralyzerConfig]) \u2192 str\n</code></pre> <p>Returns a string with some rich text tags for color to be used as the --help footer. </p> <p></p>"},{"location":"api/argument_parser/#function-show_configurable_env_vars","title":"function <code>show_configurable_env_vars</code>","text":"<pre><code>show_configurable_env_vars(config: type[YaralyzerConfig]) \u2192 None\n</code></pre> <p>Show the environment variables that can be used to set command line options, either permanently in a <code>.yaralyzer</code> file or in other standard environment variable ways. </p> <p>This file was automatically generated via lazydocs.</p>"},{"location":"api/bytes_decoder/","title":"Bytes decoder","text":""},{"location":"api/bytes_decoder/#module-bytes_decoder","title":"module <code>bytes_decoder</code>","text":"<p><code>BytesDecoder</code> class for attempting to decode bytes with various encodings. </p>"},{"location":"api/bytes_decoder/#global-variables","title":"Global Variables","text":"<ul> <li>ENCODING</li> <li>ENCODINGS_TO_ATTEMPT</li> <li>DEFAULT_TABLE_OPTIONS</li> <li>SCORE_SCALER</li> <li>WAS_DECODABLE_YES_NO</li> </ul>"},{"location":"api/bytes_decoder/#class-bytesdecoder","title":"class <code>BytesDecoder</code>","text":"<p>Handles decoding a chunk of bytes into strings using various possible encodings, ranking and displaying results. </p> <p>This class leverages the <code>chardet</code> library and custom logic to try multiple encodings, track decoding outcomes, and present the results in a rich, user-friendly format. It is used to analyze and display the possible interpretations of a byte sequence, especially in the context of YARA matches or binary analysis. </p> <p>Attributes:</p> <ul> <li><code>bytes_match</code> (BytesMatch):  The <code>BytesMatch</code> instance being decoded. </li> <li><code>label</code> (str, optional):  Label for this decoding attempt, defaults to <code>bytes_match.label</code>. </li> <li><code>bytes</code> (bytes):  The bytes (including surrounding context) to decode. </li> <li><code>decoded_strings</code> (dict[str, str]):  Maps encoding to decoded string. </li> <li><code>decodings</code> (list[DecodingAttempt]):  DecodingAttempt objects for each encoding tried. </li> <li><code>encoding_detector</code> (EncodingDetector):  Used to detect and assess possible encodings. </li> <li><code>table</code> (Table):  Table that contains the decoding attempts. </li> <li><code>was_match_decodable</code> (dict):  Tracks successful decodes per encoding. </li> <li><code>was_match_force_decoded</code> (dict):  Tracks forced decodes per encoding. </li> <li><code>was_match_undecodable</code> (dict):  Tracks failed decodes per encoding. </li> </ul> <p></p>"},{"location":"api/bytes_decoder/#method-__init__","title":"method <code>__init__</code>","text":"<pre><code>__init__(\n    bytes_match: BytesMatch,\n    label: str = '',\n    decoded_strings: dict[str, str] = &lt;factory&gt;,\n    decodings: list[DecodingAttempt] = &lt;factory&gt;,\n    was_match_decodable: defaultdict[str, int] = &lt;factory&gt;,\n    was_match_force_decoded: defaultdict[str, int] = &lt;factory&gt;,\n    was_match_undecodable: defaultdict[str, int] = &lt;factory&gt;\n) \u2192 None\n</code></pre>"},{"location":"api/bytes_decoder/#property-bytes","title":"property bytes","text":"<p>This file was automatically generated via lazydocs.</p>"},{"location":"api/bytes_match/","title":"Bytes match","text":""},{"location":"api/bytes_match/#module-bytes_match","title":"module <code>bytes_match</code>","text":"<p><code>BytesMatch</code> class for tracking regex and YARA matches against binary data. </p>"},{"location":"api/bytes_match/#global-variables","title":"Global Variables","text":"<ul> <li>BYTES_BRIGHTER</li> <li>ERROR_STYLE</li> <li>GREY_ADDRESS</li> <li>OFF_WHITE</li> </ul>"},{"location":"api/bytes_match/#class-bytesmatch","title":"class <code>BytesMatch</code>","text":"<p>Simple class to keep track of regex matches against binary data. </p> <p>Basically a Regex <code>re.match</code> object with some (not many) extra bells and whistles, most notably the <code>surrounding_bytes</code> property. </p> <p>Args:</p> <ul> <li><code>matched_against</code> (bytes):  The full byte sequence that was searched. </li> <li><code>start_idx</code> (int):  Start index of the match in the byte sequence. </li> <li><code>match_length</code> (int):  Length of the match in bytes. </li> <li><code>label</code> (str):  Label for the match (e.g., regex or YARA rule name). </li> <li><code>ordinal</code> (int):  This was the Nth match for this pattern (used for labeling only). </li> <li><code>match</code> (re.Match, optional):  Regex <code>match</code> object, if available. </li> <li><code>highlight_style</code> (str, optional):  Style to use for highlighting the match. </li> </ul> <p></p>"},{"location":"api/bytes_match/#method-__init__","title":"method <code>__init__</code>","text":"<pre><code>__init__(\n    matched_against: bytes,\n    start_idx: int,\n    match_length: int,\n    label: str,\n    ordinal: int,\n    match: Match | None = None,\n    highlight_style: str = 'orange1'\n) \u2192 None\n</code></pre>"},{"location":"api/bytes_match/#property-end_idx","title":"property end_idx","text":""},{"location":"api/bytes_match/#property-highlight_end_idx","title":"property highlight_end_idx","text":"<p>Adjust the highlighting end point in case this match is near the end of the matched bytes. </p>"},{"location":"api/bytes_match/#property-highlight_start_idx","title":"property highlight_start_idx","text":"<p>Adjust the highlighting start point in case this match is near the start of the matched bytes. </p>"},{"location":"api/bytes_match/#property-matched_bytes","title":"property matched_bytes","text":"<p>The bytes that matched the pattern. </p>"},{"location":"api/bytes_match/#property-surrounding_bytes","title":"property surrounding_bytes","text":"<p>Bytes before and after the bytes that actually matched the pattern. </p>"},{"location":"api/bytes_match/#property-surrounding_end_idx","title":"property surrounding_end_idx","text":"<p>Index of the last byte to display of those surrounding the match. </p>"},{"location":"api/bytes_match/#property-surrounding_start_idx","title":"property surrounding_start_idx","text":"<p>Index of the first byte to display of those surrounding the match. </p> <p></p>"},{"location":"api/bytes_match/#method-bytes_hashes_table","title":"method <code>bytes_hashes_table</code>","text":"<pre><code>bytes_hashes_table() \u2192 Table\n</code></pre> <p>Build a table of MD5/SHA hashes for the matched bytes. </p> <p>Returns:</p> <ul> <li><code>Table</code>:  Rich <code>Table</code> object with hashes. </li> </ul> <p></p>"},{"location":"api/bytes_match/#classmethod-from_regex_match","title":"classmethod <code>from_regex_match</code>","text":"<pre><code>from_regex_match(\n    matched_against: bytes,\n    match: Match,\n    ordinal: int,\n    highlight_style: str = 'orange1'\n) \u2192 BytesMatch\n</code></pre> <p>Alternate constructor to build a <code>BytesMatch</code> from a regex match object. </p> <p>Args:</p> <ul> <li><code>matched_against</code> (bytes):  The bytes searched. </li> <li><code>match</code> (re.Match):  The regex <code>match</code> object. </li> <li><code>ordinal</code> (int):  This was the Nth match for this pattern (used for labeling only). </li> <li><code>highlight_style</code> (str, optional):  Style for highlighting. </li> </ul> <p>Returns:</p> <ul> <li><code>BytesMatch</code>:  The constructed <code>BytesMatch</code> instance. </li> </ul> <p></p>"},{"location":"api/bytes_match/#classmethod-from_yara_match","title":"classmethod <code>from_yara_match</code>","text":"<pre><code>from_yara_match(\n    matched_against: bytes,\n    yara_match: dict,\n    highlight_style: str = 'orange1'\n) \u2192 Iterator[ForwardRef('BytesMatch')]\n</code></pre> <p>Yield a <code>BytesMatch</code> for each string returned as part of a YARA match result dict. </p> <p>Args:</p> <ul> <li><code>matched_against</code> (bytes):  The bytes searched. </li> <li><code>yara_match</code> (dict):  YARA match result dictionary. </li> <li><code>highlight_style</code> (str, optional):  Style for highlighting. </li> </ul> <p>Yields:</p> <ul> <li><code>BytesMatch</code>:  For each string match in the YARA result. </li> </ul> <p></p>"},{"location":"api/bytes_match/#classmethod-from_yara_str","title":"classmethod <code>from_yara_str</code>","text":"<pre><code>from_yara_str(\n    matched_against: bytes,\n    rule_name: str,\n    yara_str_match: StringMatch,\n    yara_str_match_instance: StringMatchInstance,\n    ordinal: int,\n    highlight_style: str = 'orange1'\n) \u2192 BytesMatch\n</code></pre> <p>Alternate constructor to build a <code>BytesMatch</code> from a YARA string match instance. </p> <p>Args:</p> <ul> <li><code>matched_against</code> (bytes):  The bytes searched. </li> <li><code>rule_name</code> (str):  Name of the YARA rule. </li> <li><code>yara_str_match</code> (StringMatch):  YARA string match object. </li> <li><code>yara_str_match_instance</code> (StringMatchInstance):  Instance of the string match. </li> <li><code>ordinal</code> (int):  The Nth match for this pattern. </li> <li><code>highlight_style</code> (str, optional):  Style for highlighting. </li> </ul> <p>Returns:</p> <ul> <li><code>BytesMatch</code>:  The constructed BytesMatch instance. </li> </ul> <p></p>"},{"location":"api/bytes_match/#method-is_decodable","title":"method <code>is_decodable</code>","text":"<pre><code>is_decodable() \u2192 bool\n</code></pre> <p>Whether the bytes are decodable depends on whether <code>SUPPRESS_DECODES_TABLE</code> is set and whether the match length is between <code>MIN</code>/<code>MAX_DECODE_LENGTH</code>. </p> <p>Returns:</p> <ul> <li><code>bool</code>:  <code>True</code> if decodable, <code>False</code> otherwise. </li> </ul> <p></p>"},{"location":"api/bytes_match/#method-location","title":"method <code>location</code>","text":"<pre><code>location() \u2192 Text\n</code></pre> <p>Get a styled <code>Text</code> object describing the start and end index of the match. </p> <p>Returns:</p> <ul> <li><code>Text</code>:  Rich Text object like '(start idx: 348190, end idx: 348228)'. </li> </ul> <p></p>"},{"location":"api/bytes_match/#method-style_at_position","title":"method <code>style_at_position</code>","text":"<pre><code>style_at_position(idx) \u2192 str\n</code></pre> <p>Get the style for the byte at position <code>idx</code> within the matched bytes. </p> <p>Args:</p> <ul> <li><code>idx</code> (int):  Index within the surrounding bytes. </li> </ul> <p>Returns:</p> <ul> <li><code>str</code>:  The style to use for this byte (highlight or greyed out). </li> </ul> <p></p>"},{"location":"api/bytes_match/#method-suppression_notice","title":"method <code>suppression_notice</code>","text":"<pre><code>suppression_notice() \u2192 Text\n</code></pre> <p>Generate a message for when the match is too short or too long to decode. </p> <p>Returns:</p> <ul> <li><code>Text</code>:  Rich <code>Text</code> object with the suppression notice. </li> </ul> <p></p>"},{"location":"api/bytes_match/#method-to_json","title":"method <code>to_json</code>","text":"<pre><code>to_json() \u2192 dict\n</code></pre> <p>Convert this <code>BytesMatch</code> to a JSON-serializable dictionary. </p> <p>Returns:</p> <ul> <li><code>dict</code>:  Dictionary representation of the match, suitable for JSON serialization. </li> </ul> <p>This file was automatically generated via lazydocs.</p>"},{"location":"api/character_encodings/","title":"Character encodings","text":""},{"location":"api/character_encodings/#module-character_encodings","title":"module <code>character_encodings</code>","text":"<p>Constants related to character encodings. </p> <p>Helpful links: </p> <ul> <li> <p>ISO-8859: www.mit.edu/people/kenta/two/iso8859.html </p> </li> <li> <p>UTF-8: www.utf8-chartable.de/unicode-utf8-table.pl?utf8=dec  # noqa: E501 </p> </li> </ul>"},{"location":"api/character_encodings/#global-variables","title":"Global Variables","text":"<ul> <li>ASCII</li> <li>ENCODING</li> <li>ISO_8859_1</li> <li>UTF_8</li> <li>UTF_16</li> <li>UTF_32</li> <li>WINDOWS_1252</li> <li>BOMS</li> <li>UNPRINTABLE_ASCII</li> <li>UNPRINTABLE_ISO_8859_1</li> <li>UNPRINTABLE_UTF_8</li> <li>UNPRINTABLE_WIN_1252</li> <li>UNPRINTABLE_ISO_8859_7</li> <li>ENCODINGS_TO_ATTEMPT</li> <li>SINGLE_BYTE_ENCODINGS</li> <li>WIDE_UTF_ENCODINGS</li> <li>ENCODINGS</li> </ul>"},{"location":"api/character_encodings/#function-scrub_c1_control_chars","title":"function <code>scrub_c1_control_chars</code>","text":"<pre><code>scrub_c1_control_chars(char_map: dict) \u2192 None\n</code></pre> <p>Fill in a <code>dict</code> with integer keys/values corresponding to where a given char encoding has no chars because this range is for C1 control chars (AKA the \"undefined\" part of most character maps). </p> <p></p>"},{"location":"api/character_encodings/#function-encoding_offsets","title":"function <code>encoding_offsets</code>","text":"<pre><code>encoding_offsets(encoding: str) \u2192 list\n</code></pre> <p>Get possible offsets for a given encoding. If the encoding is not in <code>WIDE_UTF_ENCODINGS</code>, return <code>[0]</code>. </p> <p></p>"},{"location":"api/character_encodings/#function-encoding_width","title":"function <code>encoding_width</code>","text":"<pre><code>encoding_width(encoding: str) \u2192 int\n</code></pre> <p>Get the width of a character in bytes for a given encoding, which is the number of possible offsets. </p> <p></p>"},{"location":"api/character_encodings/#function-is_wide_utf","title":"function <code>is_wide_utf</code>","text":"<pre><code>is_wide_utf(encoding: str) \u2192 bool\n</code></pre> <p>Check if the encoding is a wide UTF encoding (UTF-16 or UTF-32). </p> <p>This file was automatically generated via lazydocs.</p>"},{"location":"api/classproperty/","title":"Classproperty","text":""},{"location":"api/classproperty/#module-classproperty","title":"module <code>classproperty</code>","text":""},{"location":"api/classproperty/#class-classproperty","title":"class <code>classproperty</code>","text":"<p>Decorator that mimics chaining @classmethod and @property for a getter. From: https://stackoverflow.com/questions/76249636/class-properties-in-python-3-11 </p> <p></p>"},{"location":"api/classproperty/#method-__init__","title":"method <code>__init__</code>","text":"<pre><code>__init__(func)\n</code></pre> <p>This file was automatically generated via lazydocs.</p>"},{"location":"api/cli_option_validators/","title":"Cli option validators","text":""},{"location":"api/cli_option_validators/#module-cli_option_validators","title":"module <code>cli_option_validators</code>","text":"<p>Validators for command line arguments. </p>"},{"location":"api/cli_option_validators/#global-variables","title":"Global Variables","text":"<ul> <li>PATTERN_TYPES</li> </ul>"},{"location":"api/cli_option_validators/#class-optionvalidator","title":"class <code>OptionValidator</code>","text":"<p>Base class for CLI options validators that needs to be in its own file because of circular dependency issues. </p> <p></p>"},{"location":"api/cli_option_validators/#method-arg_type_str","title":"method <code>arg_type_str</code>","text":"<pre><code>arg_type_str() \u2192 str\n</code></pre>"},{"location":"api/cli_option_validators/#class-dirvalidator","title":"class <code>DirValidator</code>","text":"<p>DirValidator(allow_create: bool = False) </p> <p></p>"},{"location":"api/cli_option_validators/#method-__init__","title":"method <code>__init__</code>","text":"<pre><code>__init__(allow_create: bool = False) \u2192 None\n</code></pre>"},{"location":"api/cli_option_validators/#method-arg_type_str_1","title":"method <code>arg_type_str</code>","text":"<pre><code>arg_type_str() \u2192 str\n</code></pre>"},{"location":"api/cli_option_validators/#class-pathvalidator","title":"class <code>PathValidator</code>","text":""},{"location":"api/cli_option_validators/#method-arg_type_str_2","title":"method <code>arg_type_str</code>","text":"<pre><code>arg_type_str() \u2192 str\n</code></pre>"},{"location":"api/cli_option_validators/#class-patternslabelvalidator","title":"class <code>PatternsLabelValidator</code>","text":""},{"location":"api/cli_option_validators/#method-arg_type_str_3","title":"method <code>arg_type_str</code>","text":"<pre><code>arg_type_str() \u2192 str\n</code></pre>"},{"location":"api/cli_option_validators/#class-yararegexvalidator","title":"class <code>YaraRegexValidator</code>","text":""},{"location":"api/cli_option_validators/#method-arg_type_str_4","title":"method <code>arg_type_str</code>","text":"<pre><code>arg_type_str() \u2192 str\n</code></pre> <p>This file was automatically generated via lazydocs.</p>"},{"location":"api/config/","title":"Config","text":""},{"location":"api/config/#module-config","title":"module <code>config</code>","text":"<p>Configuration management for Yaralyzer. </p>"},{"location":"api/config/#global-variables","title":"Global Variables","text":"<ul> <li>YARALYZER_THEME_DICT</li> <li>EARLY_EXIT_ARGS</li> <li>ENV_VARS_OPTION</li> <li>KILOBYTE</li> <li>PNG_EXPORT_WARNING</li> <li>YARALYZE</li> <li>YARALYZER_UPPER</li> <li>DEFAULT_LOG_HANDLER_KWARGS</li> <li>LOG_FILE_LOG_FORMAT</li> <li>LOG_DIR_ENV_VAR</li> <li>LOG_LEVEL_ENV_VAR</li> <li>ARGPARSE_LOG_FORMAT</li> <li>DEFAULT_ARGV</li> </ul>"},{"location":"api/config/#class-yaralyzerconfig","title":"class <code>YaralyzerConfig</code>","text":"<p>Handles parsing of command line args and environment variables for Yaralyzer. </p> <p></p>"},{"location":"api/config/#classmethod-env_var_for_option_dest","title":"classmethod <code>env_var_for_option_dest</code>","text":"<pre><code>env_var_for_option_dest(option: str) \u2192 str\n</code></pre> <p><code>output_dir' becomes``YARALYZER_OUTPUT_DIR</code>. Overriden in pdfalyzer to distinguish yaralyzer only options. </p> <p></p>"},{"location":"api/config/#classmethod-get_env_value","title":"classmethod <code>get_env_value</code>","text":"<pre><code>get_env_value(\n    var: str,\n    var_type: Callable[[str], ~T] = &lt;class 'str'&gt;\n) \u2192 Optional[~T]\n</code></pre> <p>If called with <code>'output_dir'</code> it will check env value of <code>YARALYZER_OUTPUT_DIR</code>. </p> <p></p>"},{"location":"api/config/#classmethod-init","title":"classmethod <code>init</code>","text":"<pre><code>init(argparser: ArgumentParser) \u2192 None\n</code></pre> <p>Should be called immediately upon package load to provide the Config with the means to set itself up. </p> <p>Args:</p> <ul> <li><code>argparser</code> (ArgumentParser):  An ArgumentParser that can parse the args this app needs. </li> </ul> <p></p>"},{"location":"api/config/#classmethod-parse_args","title":"classmethod <code>parse_args</code>","text":"<pre><code>parse_args() \u2192 Namespace\n</code></pre>"},{"location":"api/config/#classmethod-prefixed_env_var","title":"classmethod <code>prefixed_env_var</code>","text":"<pre><code>prefixed_env_var(var: str) \u2192 str\n</code></pre> <p>Turns 'LOG_DIR' into 'YARALYZER_LOG_DIR' etc. </p> <p>This file was automatically generated via lazydocs.</p>"},{"location":"api/console/","title":"Console","text":""},{"location":"api/console/#module-console","title":"module <code>console</code>","text":"<p>Holds the rich.Console instance that controls the stdout printing and file export. </p>"},{"location":"api/console/#global-variables","title":"Global Variables","text":"<ul> <li>devnull</li> <li>argv</li> <li>SUPPRESS_OUTPUT_OPTION</li> <li>DEFAULT_CONSOLE_KWARGS</li> <li>console_kwargs</li> </ul>"},{"location":"api/console/#function-console_print_with_fallback","title":"function <code>console_print_with_fallback</code>","text":"<pre><code>console_print_with_fallback(_string: Text | str, style=None) \u2192 None\n</code></pre> <p><code>rich.console.print()</code> with fallback to regular <code>print()</code> if there's a Rich Markup issue. </p> <p></p>"},{"location":"api/console/#function-console_width","title":"function <code>console_width</code>","text":"<pre><code>console_width() \u2192 int\n</code></pre> <p>Current width set in <code>console</code> object. </p> <p>This file was automatically generated via lazydocs.</p>"},{"location":"api/decoding_attempt/","title":"Decoding attempt","text":""},{"location":"api/decoding_attempt/#module-decoding_attempt","title":"module <code>decoding_attempt</code>","text":"<p>Class to manage attempting to decode a chunk of bytes into strings with a given encoding. </p>"},{"location":"api/decoding_attempt/#global-variables","title":"Global Variables","text":"<ul> <li>byteorder</li> <li>ENCODINGS_TO_ATTEMPT</li> <li>SINGLE_BYTE_ENCODINGS</li> <li>UTF_8</li> <li>ERROR_STYLE</li> <li>BYTES_BRIGHTER</li> <li>BYTES_DECODED</li> <li>BYTES_NO_DIM</li> <li>GREY_ADDRESS</li> </ul>"},{"location":"api/decoding_attempt/#class-decodingattempt","title":"class <code>DecodingAttempt</code>","text":"<p>Manages the process of attempting to decode a chunk of bytes into a string using a specified encoding. </p> <p>This class tries to decode the bytes using the provided encoding, handling both standard and custom decoding strategies (including multi-byte encodings and forced decoding attempts). It tracks the outcome, highlights the decoded output, and provides information about the decoding process. </p> <p>Attributes:</p> <ul> <li><code>bytes</code> (bytes):  The bytes (including context) to decode. </li> <li><code>bytes_match</code> (BytesMatch):  The <code>BytesMatch</code> object containing match and context info. </li> <li><code>encoding</code> (str):  The encoding to attempt. </li> <li><code>encoding_label</code> (str):  Label for the encoding (may include offset info). </li> <li><code>start_offset</code> (int):  Byte offset used for decoding (for multi-byte encodings). </li> <li><code>start_offset_label</code> (Optional[str]):  String label for the offset, if used. </li> <li><code>was_force_decoded</code> (bool):  True if a forced decode was attempted. </li> <li><code>failed_to_decode</code> (bool):  True if decoding failed. </li> <li><code>decoded_string</code> (Text):  The decoded string as a Rich <code>Text</code> object (with highlighting). </li> </ul> <p></p>"},{"location":"api/decoding_attempt/#method-__init__","title":"method <code>__init__</code>","text":"<pre><code>__init__(\n    bytes_match: BytesMatch,\n    encoding: str,\n    failed_to_decode: bool = False,\n    start_offset: int = 0,\n    start_offset_label: str | None = None,\n    was_force_decoded: bool = False\n) \u2192 None\n</code></pre>"},{"location":"api/decoding_attempt/#property-bytes","title":"property bytes","text":"<p>This file was automatically generated via lazydocs.</p>"},{"location":"api/decoding_attempts_table/","title":"Decoding attempts table","text":""},{"location":"api/decoding_attempts_table/#module-decoding_attempts_table","title":"module <code>decoding_attempts_table</code>","text":"<p>Methods to build the <code>rich.table</code> used to display decoding attempts of a given bytes array. </p> <p>Final output should be a <code>rich.table</code> of decoding attempts that are sorted like this: </p> <ol> <li> <p>String representation of undecoded bytes is always the first row </p> </li> <li> <p>Encodings which <code>chardet.detect()</code> ranked as &gt; 0% likelihood are sorted based on that confidence </p> </li> <li> <p>Then the unchardetectable: </p> </li> <li> <p>Decodings that were successful, unforced, and new </p> </li> <li> <p>Decodings that were \"successful\" but forced </p> </li> <li> <p>Decodings that were the same as other decodings </p> </li> <li> <p>Failed decodings </p> </li> </ol>"},{"location":"api/decoding_attempts_table/#global-variables","title":"Global Variables","text":"<ul> <li>DEFAULT_TABLE_OPTIONS</li> </ul>"},{"location":"api/decoding_attempts_table/#function-new_decoding_attempts_table","title":"function <code>new_decoding_attempts_table</code>","text":"<pre><code>new_decoding_attempts_table(bytes_match: BytesMatch) \u2192 Table\n</code></pre> <p>Build a new rich <code>Table</code> with two rows, the raw and hex views of the <code>bytes_match</code> data. </p> <p>This file was automatically generated via lazydocs.</p>"},{"location":"api/decoding_table_row/","title":"Decoding table row","text":""},{"location":"api/decoding_table_row/#module-decoding_table_row","title":"module <code>decoding_table_row</code>","text":""},{"location":"api/decoding_table_row/#class-decodingtablerow","title":"class <code>DecodingTableRow</code>","text":"<p>Simple <code>dataclass</code> to hold a single row of a table of decoding attempts. </p> <p></p>"},{"location":"api/decoding_table_row/#method-__init__","title":"method <code>__init__</code>","text":"<pre><code>__init__(\n    encoding_label: Text,\n    confidence_text: Text,\n    was_forced_txt: Text,\n    decoded_txt: Text,\n    confidence: float,\n    encoding: str,\n    sort_score: float\n) \u2192 None\n</code></pre>"},{"location":"api/decoding_table_row/#property-encoding_label_plain","title":"property encoding_label_plain","text":""},{"location":"api/decoding_table_row/#classmethod-from_decoded_assessment","title":"classmethod <code>from_decoded_assessment</code>","text":"<pre><code>from_decoded_assessment(\n    assessment: EncodingAssessment,\n    was_forced_txt: Text,\n    decoded_txt: Text,\n    score: float\n) \u2192 DecodingTableRow\n</code></pre> <p>Alternate constructor that builds a table row for a decoding attempt. </p> <p>Args:</p> <ul> <li><code>assessment</code> (EncodingAssessment):  The <code>chardet</code> assessment for the encoding used. </li> <li><code>was_forced_txt</code> (Text):  Text indicating if the decode was forced. </li> <li><code>decoded_txt</code> (Text):  The decoded string as rich <code>Text</code> with color highlighting. </li> <li><code>score</code> (float):  The score to use for sorting this row in the table. </li> </ul> <p></p>"},{"location":"api/decoding_table_row/#classmethod-from_undecoded_assessment","title":"classmethod <code>from_undecoded_assessment</code>","text":"<pre><code>from_undecoded_assessment(\n    assessment: EncodingAssessment,\n    score: float\n) \u2192 DecodingTableRow\n</code></pre> <p>Alternate constructor for a row with just <code>chardet</code> assessment confidence data and no actual decoding attempt string. </p> <p>Args:</p> <ul> <li><code>assessment</code> (EncodingAssessment):  The <code>chardet</code> assessment for the encoding used. </li> <li><code>score</code> (float):  The score to use for sorting this row within the table. </li> </ul> <p></p>"},{"location":"api/decoding_table_row/#method-to_row_list","title":"method <code>to_row_list</code>","text":"<pre><code>to_row_list() \u2192 list[Text]\n</code></pre> <p>Returns a row for the decoding attempts table. </p> <p>This file was automatically generated via lazydocs.</p>"},{"location":"api/encoding_assessment/","title":"Encoding assessment","text":""},{"location":"api/encoding_assessment/#module-encoding_assessment","title":"module <code>encoding_assessment</code>","text":"<p>Helps with <code>chardet</code> library. </p>"},{"location":"api/encoding_assessment/#global-variables","title":"Global Variables","text":"<ul> <li>ENCODING</li> <li>DIM_COUNTRY_THRESHOLD</li> <li>CONFIDENCE</li> <li>LANGUAGE</li> </ul>"},{"location":"api/encoding_assessment/#class-encodingassessment","title":"class <code>EncodingAssessment</code>","text":"<p>Class to smooth some of the rough edges around the <code>dict</code>s returned by <code>chardet.detect_all()</code>. </p> <p>Attributes:</p> <ul> <li><code>assessment</code> (ResultDict):  The dict returned by <code>chardet.detect_all()</code>. </li> <li><code>confidence_text</code> (Text):  Rich <code>Text</code> object representing the confidence with styling. </li> <li><code>encoding_label</code> (Text):  Rich <code>Text</code> object for displaying the encoding with optional language info. </li> </ul> <p></p>"},{"location":"api/encoding_assessment/#method-__init__","title":"method <code>__init__</code>","text":"<pre><code>__init__(assessment: dict) \u2192 None\n</code></pre>"},{"location":"api/encoding_assessment/#property-confidence","title":"property confidence","text":"<p>Shift chardet confidence from 0-1.0 scale to 0-100.0 scale </p>"},{"location":"api/encoding_assessment/#property-encoding","title":"property encoding","text":"<p>The encoding detected in lowercase. </p>"},{"location":"api/encoding_assessment/#property-language","title":"property language","text":"<p>The language detected by chardet (if any). </p> <p></p>"},{"location":"api/encoding_assessment/#classmethod-dummy_encoding_assessment","title":"classmethod <code>dummy_encoding_assessment</code>","text":"<pre><code>dummy_encoding_assessment(encoding: str) \u2192 EncodingAssessment\n</code></pre> <p>Construct an empty <code>EncodingAssessment</code> to use as a dummy when <code>chardet</code> gives us nothing. </p> <p>Args:</p> <ul> <li><code>encoding</code> (str):  The encoding to use for the dummy assessment. </li> </ul> <p></p>"},{"location":"api/encoding_assessment/#method-set_encoding_label","title":"method <code>set_encoding_label</code>","text":"<pre><code>set_encoding_label(alt_text: str | None) \u2192 None\n</code></pre> <p>Alt text is displayed below the encoding in slightly dimmer font. </p> <p>Args:</p> <ul> <li><code>alt_text</code> (str | None):  Text to display along with the encoding (often the inferred language) </li> </ul> <p>This file was automatically generated via lazydocs.</p>"},{"location":"api/encoding_detector/","title":"Encoding detector","text":""},{"location":"api/encoding_detector/#module-encoding_detector","title":"module <code>encoding_detector</code>","text":"<p><code>EncodingDetector</code> class for managing chardet encoding detection. </p>"},{"location":"api/encoding_detector/#global-variables","title":"Global Variables","text":"<ul> <li>ENCODING</li> <li>OFF_WHITE</li> <li>CONFIDENCE_SCORE_RANGE</li> </ul>"},{"location":"api/encoding_detector/#class-encodingdetector","title":"class <code>EncodingDetector</code>","text":"<p>Manager class to ease dealing with the encoding detection library <code>chardet</code>. </p> <p>Each instance of this class manages a <code>chardet.detect_all()</code> scan on a single set of bytes. </p> <p>Attributes:</p> <ul> <li><code>bytes</code> (bytes):  The bytes to analyze. </li> <li><code>assessments</code> (list[EncodingAssessment]):  List of <code>EncodingAssessment</code> objects from <code>chardet</code> results. </li> <li><code>force_decode_assessments</code> (list[EncodingAssessment]):  Assessments above force decode threshold. </li> <li><code>force_display_assessments</code> (list[EncodingAssessment]):  Assessments above force display threshold. </li> <li><code>has_any_idea</code> (bool | None):  <code>True</code> if <code>chardet</code> had any idea what the encoding might be,  <code>False</code> if not, <code>None</code> if <code>chardet</code> wasn't run yet. </li> <li><code>raw_chardet_assessments</code> (list[dict]):  Raw list of dicts returned by <code>chardet.detect_all()</code>. </li> <li><code>table</code> (Table):  A rich <code>Table</code> object summarizing the chardet results. </li> <li><code>unique_assessments</code> (list[EncodingAssessment]):  Unique assessments by encoding, highest confidence only. </li> </ul> <p></p>"},{"location":"api/encoding_detector/#method-__init__","title":"method <code>__init__</code>","text":"<pre><code>__init__(\n    _bytes: bytes,\n    assessments: list[EncodingAssessment] = &lt;factory&gt;,\n    force_decode_assessments: list[EncodingAssessment] = &lt;factory&gt;,\n    force_display_assessments: list[EncodingAssessment] = &lt;factory&gt;,\n    has_any_idea: bool | None = None,\n    raw_chardet_assessments: list[dict] = &lt;factory&gt;,\n    table: Table = &lt;factory&gt;,\n    unique_assessments: list[EncodingAssessment] = &lt;factory&gt;\n) \u2192 None\n</code></pre>"},{"location":"api/encoding_detector/#property-bytes","title":"property bytes","text":""},{"location":"api/encoding_detector/#property-bytes_len","title":"property bytes_len","text":""},{"location":"api/encoding_detector/#method-get_encoding_assessment","title":"method <code>get_encoding_assessment</code>","text":"<pre><code>get_encoding_assessment(encoding: str) \u2192 EncodingAssessment\n</code></pre> <p>Get the <code>chardet</code> assessment for a specific encoding. </p> <p>Args:</p> <ul> <li><code>encoding</code> (str):  The encoding to look for. </li> </ul> <p>Returns:</p> <ul> <li><code>EncodingAssessment</code>:  Assessment for the encoding if it exists, otherwise a dummy with 0 confidence. </li> </ul> <p>This file was automatically generated via lazydocs.</p>"},{"location":"api/error/","title":"Error","text":""},{"location":"api/error/#module-error","title":"module <code>error</code>","text":"<p>Handling of internal YARA errors. </p>"},{"location":"api/error/#global-variables","title":"Global Variables","text":"<ul> <li>YARA_ERRORS_REPO_PATH</li> <li>YARA_ERRORS_RAW_URL</li> <li>YARA_ERRORS_URL</li> <li>YARA_ERROR_CODES</li> </ul>"},{"location":"api/error/#function-yara_error_msg","title":"function <code>yara_error_msg</code>","text":"<pre><code>yara_error_msg(exception: Error) \u2192 str\n</code></pre> <p>Turn a mysterious YARA error code number into a human readable string. </p> <p>This file was automatically generated via lazydocs.</p>"},{"location":"api/exceptions/","title":"Exceptions","text":""},{"location":"api/exceptions/#module-exceptions","title":"module <code>exceptions</code>","text":""},{"location":"api/exceptions/#function-print_fatal_error","title":"function <code>print_fatal_error</code>","text":"<pre><code>print_fatal_error(msg: str | Text | None, e: Exception | None = None) \u2192 None\n</code></pre> <p>Print a fatal error message </p> <p>Args:</p> <ul> <li><code>msg</code> (str):  The error message to display. </li> <li><code>e</code> (Exception | None):  The exception that caused the error, if any. </li> </ul> <p></p>"},{"location":"api/exceptions/#function-print_fatal_error_and_exit","title":"function <code>print_fatal_error_and_exit</code>","text":"<pre><code>print_fatal_error_and_exit(\n    msg: str,\n    e: Exception | None = None,\n    exit_code: int = 1\n) \u2192 None\n</code></pre> <p>Print an error message and exit with code 'exit_code'. </p> <p>This file was automatically generated via lazydocs.</p>"},{"location":"api/file_export/","title":"File export","text":""},{"location":"api/file_export/#module-file_export","title":"module <code>file_export</code>","text":"<p>Functions to export Yaralyzer results to various file formats. </p>"},{"location":"api/file_export/#global-variables","title":"Global Variables","text":"<ul> <li>INKSCAPE</li> <li>INKSCAPE_URL</li> <li>CAIROSVG_WARNING_MSG</li> </ul>"},{"location":"api/file_export/#function-export_json","title":"function <code>export_json</code>","text":"<pre><code>export_json(yaralyzer: Yaralyzer, args: Namespace) \u2192 Path\n</code></pre> <p>Export YARA scan results to JSON. </p> <p>Args:</p> <ul> <li><code>yaralyzer</code> (Yaralyzer):  The <code>Yaralyzer</code> object containing the results to export. </li> <li><code>export_basepath</code> (Path | None, Optional):  Base path to write output to. Should have no file extension. </li> </ul> <p>Returns:</p> <ul> <li><code>Path</code>:  File path data was exported to. </li> </ul> <p></p>"},{"location":"api/file_export/#function-invoke_rich_export","title":"function <code>invoke_rich_export</code>","text":"<pre><code>invoke_rich_export(export_method: Callable, args: Namespace) \u2192 None\n</code></pre> <p>Announce the export, perform the export, and announce completion. </p> <p>Args:</p> <ul> <li><code>export_method</code> (Callable):  Usually a <code>Rich.console.save_whatever()</code> method. </li> <li><code>args</code> (Namespace, optional):  Arguments parsed by ArgumeentParser. </li> </ul> <p>Returns:</p> <ul> <li><code>Path</code>:  Path data was exported to. </li> </ul> <p></p>"},{"location":"api/file_export/#function-render_png","title":"function <code>render_png</code>","text":"<pre><code>render_png(svg_path: Path, png_path: Path, args: Namespace) \u2192 Path | None\n</code></pre> <p>Turn the svg output into a png with Inkscape or cairosvg. Returns png path if successful. </p> <p>This file was automatically generated via lazydocs.</p>"},{"location":"api/file_hashes_table/","title":"File hashes table","text":""},{"location":"api/file_hashes_table/#module-file_hashes_table","title":"module <code>file_hashes_table</code>","text":"<p>Methods for computing and displaying various file hashes. </p>"},{"location":"api/file_hashes_table/#global-variables","title":"Global Variables","text":"<ul> <li>GREY_COLOR</li> <li>DEFAULT_TABLE_OPTIONS</li> </ul>"},{"location":"api/file_hashes_table/#function-bytes_hashes_table","title":"function <code>bytes_hashes_table</code>","text":"<pre><code>bytes_hashes_table(\n    bytes_or_info: bytes | BytesInfo,\n    title: str | None = None,\n    title_justify: Literal['default', 'left', 'center', 'right', 'full'] = 'left'\n) \u2192 Table\n</code></pre> <p>Build a Rich <code>Table</code> displaying the size, MD5, SHA1, and SHA256 hashes of a byte sequence. </p> <p>Args:</p> <ul> <li><code>bytes_or_info</code> (Union[bytes, BytesInfo]):  The <code>bytes</code> to hash, or a <code>BytesInfo</code>  namedtuple with precomputed values. </li> <li><code>title</code> (str | None, optional):  Optional title for the table. Defaults to <code>None</code>. </li> <li><code>title_justify</code> (JustifyMethod, optional):  Justification for the table title. Defaults to <code>\"LEFT\"</code>. </li> </ul> <p>Returns:</p> <ul> <li><code>Table</code>:  A Rich <code>Table</code> object with the size and hash values. </li> </ul> <p></p>"},{"location":"api/file_hashes_table/#class-bytesinfo","title":"class <code>BytesInfo</code>","text":"<p>Compute the size, MD5, SHA1, and SHA256 hashes for some bytes. </p> <p></p>"},{"location":"api/file_hashes_table/#method-__init__","title":"method <code>__init__</code>","text":"<pre><code>__init__(_bytes: bytes) \u2192 None\n</code></pre>"},{"location":"api/file_hashes_table/#property-md5","title":"property md5","text":""},{"location":"api/file_hashes_table/#property-sha1","title":"property sha1","text":""},{"location":"api/file_hashes_table/#property-sha256","title":"property sha256","text":""},{"location":"api/file_hashes_table/#property-size","title":"property size","text":""},{"location":"api/file_hashes_table/#classmethod-for_file","title":"classmethod <code>for_file</code>","text":"<pre><code>for_file(file_path: str | Path) \u2192 BytesInfo\n</code></pre> <p>Alternate constructor that reads the bytes from <code>file_path</code>. </p> <p></p>"},{"location":"api/file_hashes_table/#method-hash_dict","title":"method <code>hash_dict</code>","text":"<pre><code>hash_dict() \u2192 dict[str, str]\n</code></pre> <p>This file was automatically generated via lazydocs.</p>"},{"location":"api/regex_match_metrics/","title":"Regex match metrics","text":""},{"location":"api/regex_match_metrics/#module-regex_match_metrics","title":"module <code>regex_match_metrics</code>","text":"<p><code>RegexMatchMetrics</code> class. </p> <p></p>"},{"location":"api/regex_match_metrics/#class-regexmatchmetrics","title":"class <code>RegexMatchMetrics</code>","text":"<p>Class to measure what we enounter as we iterate over all matches of a relatively simple byte level regex. </p> <p>Things like how much many of our matched bytes were we able to decode easily vs. by force vs. not at all, were some encodings have a higher pct of success than others (indicating part of our mystery data might be encoded that way? </p> <p>Example:   \"Find bytes between quotes\" against a relatively large pool of close to random encrypted binary data. </p> <p>Attributes:</p> <ul> <li><code>match_count</code> (int):  Total number of matches found. </li> <li><code>bytes_matched</code> (int):  Total number of bytes matched across all matches. </li> <li><code>matches_decoded</code> (int):  Number of matches where we were able to decode at least some of the matched bytes. </li> <li><code>easy_decode_count</code> (int):  Number of matches where we were able to decode the matched bytes without forcing. </li> <li><code>forced_decode_count</code> (int):  Number of matches where we were only able to decode the matched bytes by forcing. </li> <li><code>undecodable_count</code> (int):  Number of matches where we were unable to decode any of the matched bytes. </li> <li><code>skipped_matches_lengths</code> (defaultdict):  Dictionary mapping lengths of skipped matches to their counts. </li> <li><code>bytes_match_objs</code> (list):  List of <code>BytesMatch</code> objects for all matches encountered. </li> <li><code>per_encoding_stats</code> (defaultdict):  Dictionary mapping encoding names to their respective <code>RegexMatchMetrics</code>. </li> </ul> <p></p>"},{"location":"api/regex_match_metrics/#method-__init__","title":"method <code>__init__</code>","text":"<pre><code>__init__(\n    match_count: int = 0,\n    bytes_matched: int = 0,\n    matches_decoded: int = 0,\n    easy_decode_count: int = 0,\n    forced_decode_count: int = 0,\n    undecodable_count: int = 0,\n    skipped_matches_lengths: dict[int, int] = &lt;factory&gt;,\n    bytes_match_objs: list[BytesMatch] = &lt;factory&gt;,\n    per_encoding_stats: dict[str, 'RegexMatchMetrics'] = &lt;factory&gt;\n) \u2192 None\n</code></pre>"},{"location":"api/regex_match_metrics/#method-num_matches_skipped_for_being_empty","title":"method <code>num_matches_skipped_for_being_empty</code>","text":"<pre><code>num_matches_skipped_for_being_empty() \u2192 int\n</code></pre> <p>Number of matches skipped for being empty (0 length). </p> <p></p>"},{"location":"api/regex_match_metrics/#method-num_matches_skipped_for_being_too_big","title":"method <code>num_matches_skipped_for_being_too_big</code>","text":"<pre><code>num_matches_skipped_for_being_too_big() \u2192 int\n</code></pre> <p>Number of matches skipped for being too big to decode. </p> <p></p>"},{"location":"api/regex_match_metrics/#method-tally_match","title":"method <code>tally_match</code>","text":"<pre><code>tally_match(decoder: BytesDecoder) \u2192 None\n</code></pre> <p>Tally statistics from a <code>BytesDecoder</code> after it has processed a match. </p> <p>Args:</p> <ul> <li><code>decoder</code> (BytesDecoder):  The <code>BytesDecoder</code> that processed a match. </li> </ul> <p>This file was automatically generated via lazydocs.</p>"},{"location":"api/theme/","title":"Theme","text":""},{"location":"api/theme/#module-theme","title":"module <code>theme</code>","text":"<p>Color theme stuff. Rich color names TODO: interesting colors # row_styles[0] = 'reverse bold on color(144)' &lt;- </p>"},{"location":"api/theme/#global-variables","title":"Global Variables","text":"<ul> <li>BYTES</li> <li>BYTES_BRIGHTER</li> <li>BYTES_DECODED</li> <li>BYTES_HIGHLIGHT</li> <li>BYTES_NO_DIM</li> <li>ERROR_STYLE</li> <li>DARK_GREY</li> <li>GREY</li> <li>GREY_ADDRESS</li> <li>GREY_COLOR</li> <li>OFF_WHITE</li> <li>PEACH</li> <li>YARALYZER_THEME_DICT</li> <li>LOG_THEME_DICT</li> <li>MAX_SHOW_COLORS_COL_SIZE</li> <li>CLI_OPTION_TYPE_STYLES</li> </ul>"},{"location":"api/theme/#function-argparse_style","title":"function <code>argparse_style</code>","text":"<pre><code>argparse_style(category: str) \u2192 str\n</code></pre> <p>RichHelpFormatterPlus strings:  https://github.com/michelcrypt4d4mus/rich-argparse-plus/blob/rich_argparse_plus/rich_argparse_plus/themes.py </p> <p></p>"},{"location":"api/theme/#function-color_theme_grid","title":"function <code>color_theme_grid</code>","text":"<pre><code>color_theme_grid(styles: dict, app_name: str) \u2192 Padding\n</code></pre> <p>Lay out the colors in 'styles' in a grid with a header panel. </p> <p></p>"},{"location":"api/theme/#function-theme_colors_with_prefix","title":"function <code>theme_colors_with_prefix</code>","text":"<pre><code>theme_colors_with_prefix(prefix: str) \u2192 list[Text]\n</code></pre> <p>Return a list of (name, style) <code>Text</code> objects for all styles in the theme that start with <code>prefix</code>. </p> <p>This file was automatically generated via lazydocs.</p>"},{"location":"api/timeout/","title":"Timeout","text":""},{"location":"api/timeout/#module-timeout","title":"module <code>timeout</code>","text":""},{"location":"api/timeout/#function-timeout","title":"function <code>timeout</code>","text":"<pre><code>timeout(seconds=5, default=None)\n</code></pre> <p>From: https://stackoverflow.com/questions/75928586/how-to-stop-the-execution-of-a-function-in-python-after-a-certain-time </p> <p>Example:   @timeout(seconds=5, default=None)  def function():  sleep(6000) </p> <p>This file was automatically generated via lazydocs.</p>"},{"location":"api/yara_match/","title":"Yara match","text":""},{"location":"api/yara_match/#module-yara_match","title":"module <code>yara_match</code>","text":"<p>Rich text decorator for YARA match dicts. </p> <p>A YARA match is returned as a <code>dict</code> with this structure: </p> <p>Example: <code>{          'tags': ['foo', 'bar'],          'matches': True,          'namespace': 'default',          'rule': 'my_rule',          'meta': {},          'strings': [              StringMatch1,              StringMatch2          ]      }</code> </p>"},{"location":"api/yara_match/#global-variables","title":"Global Variables","text":"<ul> <li>DEFAULT_TABLE_OPTIONS</li> <li>INDENT_SPACES</li> <li>MATCH_PADDING</li> <li>YARA_STRING_STYLES</li> <li>RAW_YARA_THEME_COLORS</li> </ul>"},{"location":"api/yara_match/#class-yaramatch","title":"class <code>YaraMatch</code>","text":"<p>Rich text decorator for YARA match dicts. </p> <p></p>"},{"location":"api/yara_match/#method-__init__","title":"method <code>__init__</code>","text":"<pre><code>__init__(match: dict, matched_against_bytes_label: Text) \u2192 None\n</code></pre> <p>Args:</p> <ul> <li><code>match</code> (dict):  The YARA match dict. </li> <li><code>matched_against_bytes_label</code> (Text):  Label indicating what bytes were matched against. </li> </ul> <p>This file was automatically generated via lazydocs.</p>"},{"location":"api/yara_rule_builder/","title":"Yara rule builder","text":""},{"location":"api/yara_rule_builder/#module-yara_rule_builder","title":"module <code>yara_rule_builder</code>","text":"<p>Builds bare bones YARA rules to match strings and regex patterns. </p> <p>Example rule string: </p> <pre><code>rule Just_A_Piano_Man {\n     meta:\n         author           = \"Tim\"\n     strings:\n         $hilton_producer = /Scott.*Storch/\n     condition:\n         $hilton_producer\n}\n</code></pre>"},{"location":"api/yara_rule_builder/#global-variables","title":"Global Variables","text":"<ul> <li>YARALYZE</li> <li>HEX</li> <li>REGEX</li> <li>PATTERN_TYPES</li> <li>YARA_REGEX_MODIFIERS</li> <li>PATTERN</li> <li>RULE</li> <li>UNDERSCORE</li> <li>SAFE_LABEL_REPLACEMENTS</li> <li>RULE_TEMPLATE</li> <li>BYTES_RULE_TEMPLATE</li> </ul>"},{"location":"api/yara_rule_builder/#function-yara_rule_string","title":"function <code>yara_rule_string</code>","text":"<pre><code>yara_rule_string(\n    pattern: str,\n    pattern_type: Literal['hex', 'regex'] = 'regex',\n    rule_name: str = 'yaralyze',\n    pattern_label: Optional[str] = 'pattern',\n    modifier: Optional[Literal['ascii', 'fullword', 'nocase', 'wide']] = None\n) \u2192 str\n</code></pre> <p>Build a YARA rule string for a given <code>pattern</code>. </p> <p>Args:</p> <ul> <li><code>pattern</code> (str):  The string or regex pattern to match. </li> <li><code>pattern_type</code> (str):  Either <code>\"regex\"</code> or <code>\"hex\"</code>. Default is <code>\"regex\"</code>. </li> <li><code>rule_name</code> (str):  The name of the YARA rule. Default is <code>\"YARALYZE\"</code>. </li> <li><code>pattern_label</code> (Optional[str]):  The label for the pattern in the YARA rule. Default is <code>\"pattern\"</code>. </li> <li><code>modifier</code> (Optional[str]):  Optional regex modifier (e.g. 'fullword', 'nocase', 'ascii', 'wide').  Only valid if <code>pattern_type</code> is <code>\"regex\"</code>. </li> </ul> <p>Returns:</p> <ul> <li><code>str</code>:  The constructed YARA rule as a string. </li> </ul> <p></p>"},{"location":"api/yara_rule_builder/#function-build_yara_rule","title":"function <code>build_yara_rule</code>","text":"<pre><code>build_yara_rule(\n    pattern: str,\n    pattern_type: Literal['hex', 'regex'] = 'regex',\n    rule_name: str = 'yaralyze',\n    pattern_label: Optional[str] = 'pattern',\n    modifier: Optional[Literal['ascii', 'fullword', 'nocase', 'wide']] = None\n) \u2192 Rule\n</code></pre> <p>Build a compiled <code>yara.Rule</code> object. </p> <p>Args:</p> <ul> <li><code>pattern</code> (str):  The string or regex pattern to match. </li> <li><code>pattern_type</code> (str):  Either <code>\"regex\"</code> or <code>\"hex\"</code>. Default is <code>\"regex\"</code>. </li> <li><code>rule_name</code> (str):  The name of the YARA rule. Default is <code>\"YARALYZE\"</code>. </li> <li><code>pattern_label</code> (Optional[str]):  The label for the pattern in the YARA rule. Default is <code>\"pattern\"</code>. </li> <li><code>modifier</code> (Optional[str]):  Optional regex modifier (e.g. 'nocase', 'ascii', 'wide', 'fullword').  Only valid if <code>pattern_type</code> is <code>\"regex\"</code>. </li> </ul> <p>Returns:</p> <ul> <li><code>yara.Rule</code>:  Compiled YARA rule object. </li> </ul> <p></p>"},{"location":"api/yara_rule_builder/#function-safe_label","title":"function <code>safe_label</code>","text":"<pre><code>safe_label(_label: str) \u2192 str\n</code></pre> <p>YARA rule and pattern names can only contain alphanumeric chars. </p> <p>Args:</p> <ul> <li><code>_label</code> (str):  The label to sanitize. </li> </ul> <p>Returns:</p> <ul> <li><code>str</code>:  A sanitized label safe for use in YARA rules. </li> </ul> <p>This file was automatically generated via lazydocs.</p>"},{"location":"api/yaralyzer/","title":"Yaralyzer","text":""},{"location":"api/yaralyzer/#module-yaralyzer","title":"module <code>yaralyzer</code>","text":"<p>Main Yaralyzer class and alternate constructors. </p>"},{"location":"api/yaralyzer/#global-variables","title":"Global Variables","text":"<ul> <li>output</li> <li>util</li> <li>config</li> <li>bytes_match</li> <li>decoding</li> <li>encoding_detection</li> <li>yaralyzer</li> <li>HEX</li> <li>REGEX</li> <li>BYTES_BRIGHTER</li> <li>MAX_FILENAME_LENGTH</li> <li>YARALYZE</li> <li>YARA_FILE_DOES_NOT_EXIST_ERROR_MSG</li> </ul>"},{"location":"api/yaralyzer/#function-yaralyze","title":"function <code>yaralyze</code>","text":"<pre><code>yaralyze()\n</code></pre> <p>Entry point for Yaralyzer when invoked as a script. Args are parsed from the command line and environment variables. See <code>yaralyze --help</code> for details. </p> <p></p>"},{"location":"api/yaralyzer/#class-yaralyzer","title":"class <code>Yaralyzer</code>","text":"<p>Central class that handles setting up / compiling YARA rules and reading binary data from files as needed. </p> <p>Alternate constructors are provided depending on whether: </p> <ul> <li> <p>YARA rules are already compiled </p> </li> <li> <p>YARA rules should be compiled from a string </p> </li> <li> <p>YARA rules should be read from a file </p> </li> <li> <p>YARA rules should be read from a directory of .yara files </p> </li> </ul> <p>The real action happens in the <code>__rich__console__()</code> dunder method. </p> <p>Attributes:</p> <ul> <li><code>rules</code> (yara.Rules):  The YARA rules to use for scanning. </li> <li><code>rules_label</code> (str):  A label for the ruleset, typically derived from filenames or user input. </li> <li><code>scannable</code> (bytes | str | Path):  The data to scan. If it's <code>bytes</code> then that data is scanned;  if it's a string it is treated as a file path to load bytes from. </li> <li><code>scannable_label</code> (str, optional):  A label for the binary data. Required if <code>scannable</code> is raw  <code>bytes</code>, otherwise defaults to the basename of <code>scannable</code> file. </li> <li><code>highlight_style</code> (str, optional):  The style to use for highlighting matches in the output. </li> <li><code>_bytes</code> (bytes):  The binary data to scan, derived from the <code>scannable</code> arg. </li> <li><code>non_matches</code> (list[dict]):  A list of YARA rules that did not match the binary data. </li> <li><code>matches</code> (list[YaraMatch]):  A list of YaraMatch objects representing the matches found. </li> <li><code>extraction_stats</code> (RegexMatchMetrics):  Metrics related to decoding attempts on matched data </li> </ul> <p>Raises:</p> <ul> <li><code>TypeError</code>:  If <code>scannable</code> is <code>bytes</code> and <code>scannable_label</code> is not provided. </li> </ul> <p></p>"},{"location":"api/yaralyzer/#method-__init__","title":"method <code>__init__</code>","text":"<pre><code>__init__(\n    rules: Rules,\n    rules_label: str,\n    scannable: str | bytes | Path,\n    scannable_label: str = '',\n    highlight_style: str = 'orange1',\n    non_matches: list[dict] = &lt;factory&gt;,\n    matches: list[YaraMatch] = &lt;factory&gt;,\n    extraction_stats: RegexMatchMetrics = &lt;factory&gt;\n) \u2192 None\n</code></pre>"},{"location":"api/yaralyzer/#method-export_basepath","title":"method <code>export_basepath</code>","text":"<pre><code>export_basepath() \u2192 Path\n</code></pre> <p>Get the basepath (directory + filename without extension) for exported files. </p> <p></p>"},{"location":"api/yaralyzer/#classmethod-for_patterns","title":"classmethod <code>for_patterns</code>","text":"<pre><code>for_patterns(\n    patterns: list[str],\n    patterns_type: Literal['hex', 'regex'],\n    scannable: bytes | str | Path,\n    scannable_label: str = '',\n    rules_label: str | None = None,\n    pattern_label: str | None = None,\n    regex_modifier: Optional[Literal['ascii', 'fullword', 'nocase', 'wide']] = None\n) \u2192 Yaralyzer\n</code></pre> <p>Alternate constructor taking regex pattern strings. Rules label defaults to the patterns joined by comma. </p> <p>Args:</p> <ul> <li><code>patterns</code> (list[str]):  list of regex or hex patterns to build rules from. </li> <li><code>patterns_type</code> (PatternType):  Either <code>\"regex\"</code> or <code>\"hex\"</code> to indicate the type of patterns provided. </li> <li><code>scannable</code> (Union[bytes, str]):  The data to scan. If <code>bytes</code>, raw data is scanned;  if <code>str</code>, it is treated as a file path to load bytes from. </li> <li><code>scannable_label</code> (str | None, optional):  Label for the <code>scannable</code> data. Required if <code>scannable</code> is <code>bytes</code>.  If scannable is a file path, defaults to the file's basename. </li> <li><code>rules_label</code> (str | None, optional):  Label for the ruleset. Defaults to the patterns joined by comma. </li> <li><code>pattern_label</code> (str | None, optional):  Label for each pattern in the YARA rules. Defaults to \"pattern\". </li> <li><code>regex_modifier</code> (str | None, optional):  Optional regex modifier (e.g. \"nocase\", \"ascii\", \"wide\", etc).  Only valid if <code>patterns_type</code> is <code>\"regex\"</code>. </li> </ul> <p></p>"},{"location":"api/yaralyzer/#classmethod-for_rules_dirs","title":"classmethod <code>for_rules_dirs</code>","text":"<pre><code>for_rules_dirs(\n    dirs: list[str] | list[Path] | list[str | Path],\n    scannable: bytes | str | Path,\n    scannable_label: str = ''\n) \u2192 Yaralyzer\n</code></pre> <p>Alternate constructor that will load all <code>.yara</code> files in <code>yara_rules_dir</code>. </p> <p>Args:</p> <ul> <li><code>dirs</code> (list[str]):  list of directories to search for <code>.yara</code> files. </li> <li><code>scannable</code> (Union[bytes, str]):  The data to scan. If <code>bytes</code>, raw data is scanned;  if <code>str</code>, it is treated as a file path to load bytes from. </li> <li><code>scannable_label</code> (str | None, optional):  Label for the <code>scannable</code> data.  Required if <code>scannable</code> is <code>bytes</code>. If scannable is a file path, defaults to the file's basename. </li> </ul> <p>Raises:</p> <ul> <li><code>FileNotFoundError</code>:  If <code>dirs</code> is not a list of valid directories. </li> </ul> <p></p>"},{"location":"api/yaralyzer/#classmethod-for_rules_files","title":"classmethod <code>for_rules_files</code>","text":"<pre><code>for_rules_files(\n    yara_rules_files: list[str] | list[Path],\n    scannable: bytes | str | Path,\n    scannable_label: str = ''\n) \u2192 Yaralyzer\n</code></pre> <p>Alternate constructor to load YARA rules from files and label rules with the filenames. </p> <p>Args:</p> <ul> <li><code>yara_rules_files</code> (list[str]):  list of file paths to YARA rules files. </li> <li><code>scannable</code> (Union[bytes, str]):  The data to scan. If <code>bytes</code>, raw data is scanned;  if <code>str</code>, it is treated as a file path to load bytes from. </li> <li><code>scannable_label</code> (str, optional):  Label for the <code>scannable</code> data.  Required if <code>scannable</code> is <code>bytes</code>. If scannable is a file path, defaults to the file's basename. </li> </ul> <p>Raises:</p> <ul> <li><code>FileNotFoundError</code>:  If any file in <code>yara_rules_files</code> does not exist. </li> <li><code>TypeError</code>:  If <code>yara_rules_files</code> is not a list of Paths or strings </li> </ul> <p></p>"},{"location":"api/yaralyzer/#method-match_iterator","title":"method <code>match_iterator</code>","text":"<pre><code>match_iterator() \u2192 Iterator[tuple[BytesMatch, BytesDecoder]]\n</code></pre> <p>Iterator version of <code>yaralyze()</code>. </p> <p>Yields:</p> <ul> <li><code>tuple[BytesMatch, BytesDecoder]</code>:  Match and decode data tuple. </li> </ul> <p></p>"},{"location":"api/yaralyzer/#method-yaralyze","title":"method <code>yaralyze</code>","text":"<pre><code>yaralyze() \u2192 None\n</code></pre> <p>Use YARA to find matches and then force decode them. </p> <p>This file was automatically generated via lazydocs.</p>"}]}